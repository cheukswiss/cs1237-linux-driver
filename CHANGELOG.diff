commit f2aa994c863fc736bccc07950decefd92b8b9035
Author: zhengzhuorui <zhengzhuorui@anycubic.com>
Date:   Tue Apr 29 09:56:37 2025 +0800

    perf(cs1237): 修正电压参考单位于数据处理方式，优化 SPI 读写
    
    - 将参考电压 ref 的注释单位 mV 修正为 μV
    - 修改函数名称 cs1237_get_votage -> cs1237_get_voltage，并完善注释
    - 优化电压计算公式，移除多余的*1000000，确保单位移植
    - 优化 SPI 读写实现，提升代码效率
    - 优化 ADC 24位数据扩展到32位的方式
    - 在 tasklet 处理中添加 unlikely 以提升分支预测性能
    
    本次变更不影响外部接口
    
    Change-Id: I2155ba3394a82e1a94d9bf63be6505b2bb8e05ff
    Signed-off-by: zhengzhuorui <zhengzhuorui@anycubic.com>
---
 drivers/misc/anycubic/cs1237.c | 30 ++++++++++++++----------------
 1 file changed, 14 insertions(+), 16 deletions(-)

diff --git a/drivers/misc/anycubic/cs1237.c b/drivers/misc/anycubic/cs1237.c
index 1f439d8d..fbcb06bb 100644
--- a/drivers/misc/anycubic/cs1237.c
+++ b/drivers/misc/anycubic/cs1237.c
@@ -49,7 +49,7 @@ struct cs1237_data {
 	cs1237_config_t config;
 	unsigned 	dclk;	/* gpio: sclk */
 	unsigned 	dio;	/* gpio: DRDY/DOUT */
-	int 		ref;	/* ref voltage mV */
+	int 		ref;	/* ref voltage μV */
 	unsigned long	stamp;	/* read time stamp */
 	unsigned long	freq;	/* data ready time */
 	unsigned long	dlock;	/* data update time */
@@ -162,13 +162,16 @@ static inline bool cs1237_data_validate(uint32_t value)
 /**
  * @brief convert adc value to voltage
  * 	voltage: (±0.5Vref/gain)/(2^23-1) * value
+ * @param value: adc value
+ * @return voltage(μV)
  */
-static inline int64_t cs1237_get_votage(int64_t value)
+static inline int64_t cs1237_get_voltage(int64_t value)
 {
 	struct cs1237_data *data = cs1237_get_data();
 	int64_t ref  = data->ref;
 	int64_t gain = cs1237_get_gain(data->config.pga);
-	return ((ref * value * 1000000) / (gain * 0xFFFFFF));
+	const int64_t full_scale = 0xFFFFFF;
+	return ((ref * value) / (gain * full_scale));
 }
 
 static inline uint32_t cs1237_spi_read(uint8_t bits)
@@ -177,13 +180,12 @@ static inline uint32_t cs1237_spi_read(uint8_t bits)
 	uint32_t value = 0;
 	uint8_t i;
 
+	/* MSB first */
 	for (i = 0; i < bits; i++) {
 		spi_set_value(data->dclk, 1);
 		ndelay(500);
 
-		value <<= 1;
-		if (spi_get_value(data->dio))
-			value |= 1;
+		value = (value << 1) | spi_get_value(data->dio);
 
 		spi_set_value(data->dclk, 0);
 		ndelay(500);
@@ -196,16 +198,15 @@ static inline void cs1237_spi_write(uint32_t value, uint8_t bits)
 {
 	struct cs1237_data *data = cs1237_get_data();
 	uint8_t i;
+	
+	compiletime_assert(bits <= 8, "bits must be less than 8");
 
 	for (i = 0; i < bits; i++) {
 		spi_set_value(data->dclk, 1);
 		ndelay(500);
 
 		/* MSB first */
-		if (value & 0x80)
-			spi_set_value(data->dio, 1);
-		else
-			spi_set_value(data->dio, 0);
+		spi_set_value(data->dio, value & 0x80);
 		value <<= 1;
 
 		spi_set_value(data->dclk, 0);
@@ -268,10 +269,7 @@ static inline bool cs1237_read_adc(int32_t *val)
 		return false;
 	}
 
-	*val = data->adc_value;
-	/* 24bit extend to 32bit */
-	if (*val & (1 << 23))
-		*val |= -(((~(*val)) & 0x007FFFFF) + 1);
+	*val = (data->adc_value << 8) >> 8; /* 24bit extend to 32bit */
 
 	enable_irq(data->irq);
 	data->status = CS1237_STATUS_PREPARE;
@@ -289,10 +287,10 @@ static void cs1237_tasklet_handler(unsigned long arg)
 		break;
 
 	case CS1237_STATUS_PREPARE:
-		if (spi_get_value(data->dio))
+		if (unlikely(spi_get_value(data->dio)))
 			break;
 
-		if (time_after(jiffies, data->stamp + data->freq))
+		if (unlikely(time_after(jiffies, data->stamp + data->freq)))
 			break;
 
 		disable_irq(data->irq);

commit fdbc84a6a85f4217e910683fa35b1e34e88b1792
Author: zhengzhuorui <zhengzhuorui@anycubic.com>
Date:   Thu Feb 13 10:39:47 2025 +0800

    fix: 解决拉力传感器 cs1237中断使能不平衡问题
    
    Change-Id: Iff5312b5144b99a5f8c354e1c2631a5516b70deb
    Signed-off-by: zhengzhuorui <zhengzhuorui@anycubic.com>
---
 drivers/misc/anycubic/cs1237.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/drivers/misc/anycubic/cs1237.c b/drivers/misc/anycubic/cs1237.c
index f2a194e6..1f439d8d 100644
--- a/drivers/misc/anycubic/cs1237.c
+++ b/drivers/misc/anycubic/cs1237.c
@@ -263,6 +263,10 @@ static inline bool cs1237_read_adc(int32_t *val)
 	struct cs1237_data *data = cs1237_get_data();
 
 	spin_lock_irqsave(&data->slock, data->flags);
+	if (unlikely(data->status != CS1237_STATUS_READY)) {
+		spin_unlock_irqrestore(&data->slock, data->flags);
+		return false;
+	}
 
 	*val = data->adc_value;
 	/* 24bit extend to 32bit */

commit af2a9a11671cf120eaf2544f68e288596c95fcf0
Author: zhengzhuorui <zhengzhuorui@anycubic.com>
Date:   Thu Feb 13 10:39:01 2025 +0800

    perf: 直接使用底层接口优化拉力传感器 cs1237 spi 接口的读写
    
    Change-Id: Ib677cd52a64f5d42b44114dd42fc8761c74106cb
    Signed-off-by: zhengzhuorui <zhengzhuorui@anycubic.com>
---
 drivers/misc/anycubic/cs1237.c | 28 ++++++++++++++++++++--------
 1 file changed, 20 insertions(+), 8 deletions(-)

diff --git a/drivers/misc/anycubic/cs1237.c b/drivers/misc/anycubic/cs1237.c
index 6a58c920..f2a194e6 100644
--- a/drivers/misc/anycubic/cs1237.c
+++ b/drivers/misc/anycubic/cs1237.c
@@ -84,6 +84,18 @@ struct miscdevice cs1237_device = {
 #define cs1237_get_pdev() dev_get_drvdata(cs1237_device.this_device)
 #define cs1237_get_data() platform_get_drvdata(dev_get_drvdata(cs1237_device.this_device))
 
+#ifdef CONFIG_MS_GPIO
+extern void MDrv_GPIO_Set_High(uint8_t u8IndexGPIO);
+extern void MDrv_GPIO_Set_Low(uint8_t u8IndexGPIO);
+extern uint8_t MDrv_GPIO_Pad_Read(uint8_t u8IndexGPIO);
+
+#define spi_get_value(gpio) MDrv_GPIO_Pad_Read(gpio)
+#define spi_set_value(gpio, value) (value ? MDrv_GPIO_Set_High(gpio) : MDrv_GPIO_Set_Low(gpio))
+#else
+#define spi_get_value(gpio) gpio_get_value(gpio)
+#define spi_set_value(gpio, value) gpio_set_value(gpio, value)
+#endif
+
 #if 0
 static void cs1237_hw_reset(void)
 {
@@ -166,14 +178,14 @@ static inline uint32_t cs1237_spi_read(uint8_t bits)
 	uint8_t i;
 
 	for (i = 0; i < bits; i++) {
-		gpio_set_value(data->dclk, 1);
+		spi_set_value(data->dclk, 1);
 		ndelay(500);
 
 		value <<= 1;
-		if (gpio_get_value(data->dio))
+		if (spi_get_value(data->dio))
 			value |= 1;
 
-		gpio_set_value(data->dclk, 0);
+		spi_set_value(data->dclk, 0);
 		ndelay(500);
 	}
 
@@ -186,17 +198,17 @@ static inline void cs1237_spi_write(uint32_t value, uint8_t bits)
 	uint8_t i;
 
 	for (i = 0; i < bits; i++) {
-		gpio_set_value(data->dclk, 1);
+		spi_set_value(data->dclk, 1);
 		ndelay(500);
 
 		/* MSB first */
 		if (value & 0x80)
-			gpio_set_value(data->dio, 1);
+			spi_set_value(data->dio, 1);
 		else
-			gpio_set_value(data->dio, 0);
+			spi_set_value(data->dio, 0);
 		value <<= 1;
 
-		gpio_set_value(data->dclk, 0);
+		spi_set_value(data->dclk, 0);
 		ndelay(500);
 	}
 }
@@ -273,7 +285,7 @@ static void cs1237_tasklet_handler(unsigned long arg)
 		break;
 
 	case CS1237_STATUS_PREPARE:
-		if (gpio_get_value(data->dio))
+		if (spi_get_value(data->dio))
 			break;
 
 		if (time_after(jiffies, data->stamp + data->freq))

commit c4b749d4cd532624ecfd04c98da17772a02bd7df
Author: zhengzhuorui <zhengzhuorui@anycubic.com>
Date:   Mon Jul 15 16:19:22 2024 +0800

    gw-fpga: open_count <= 1
    
    Change-Id: I39bcf47fdf83f56728a23eabf16ff28af3d682ad
---
 drivers/misc/anycubic/cs1237.c | 31 ++++++++++++++++++++++++++++++-
 1 file changed, 30 insertions(+), 1 deletion(-)

diff --git a/drivers/misc/anycubic/cs1237.c b/drivers/misc/anycubic/cs1237.c
index cb9b1edc..6a58c920 100644
--- a/drivers/misc/anycubic/cs1237.c
+++ b/drivers/misc/anycubic/cs1237.c
@@ -12,8 +12,10 @@
 #include <linux/jiffies.h>
 #include <linux/spinlock.h>
 #include <linux/uaccess.h>
+#ifdef CONFIG_IIO
 #include <linux/iio/iio.h>
 #include <linux/iio/consumer.h>
+#endif
 #include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/poll.h>
@@ -31,8 +33,10 @@ enum {
 
 struct cs1237_data {
 	struct platform_device	*pdev;
+#ifdef CONFIG_IIO
 	struct iio_dev		*indio_dev;
 	struct iio_chan_spec	channels[CS1237_NUM_CHANNELS];
+#endif
 	struct tasklet_struct	tasklet;
 	spinlock_t 		slock;
 	wait_queue_head_t	wait;
@@ -446,6 +450,7 @@ static unsigned int cs1237_poll(struct file *file, poll_table *wait)
 	return mask;
 }
 
+#ifdef CONFIG_IIO
 static int cs1237_read_raw(struct iio_dev *indio_dev,
 			   const struct iio_chan_spec *chan,
 			   int *val, int *val2, long mask)
@@ -470,6 +475,7 @@ static int cs1237_read_raw(struct iio_dev *indio_dev,
 static const struct iio_info cs1237_info = {
 	.read_raw = cs1237_read_raw,
 };
+#endif
 
 static int cs1237_remove(struct platform_device *pdev)
 {
@@ -481,7 +487,9 @@ static int cs1237_remove(struct platform_device *pdev)
 	
 	misc_deregister(&cs1237_device);
 
+#ifdef CONFIG_IIO
 	iio_device_unregister(data->indio_dev);
+#endif
 
 	return 0;
 }
@@ -491,7 +499,9 @@ static int cs1237_probe(struct platform_device *pdev)
 	int ret;
 	struct device_node *np;
 	struct cs1237_data *data;
+#ifdef CONFIG_IIO
 	struct iio_dev *indio_dev;
+#endif
 
 	np = of_find_compatible_node(pdev->dev.of_node, NULL, "cs1237");
 	if (!np) {
@@ -500,14 +510,22 @@ static int cs1237_probe(struct platform_device *pdev)
 	}
 	dev_info(&pdev->dev, "compatible: %s\n", np->name);
 
+#ifdef CONFIG_IIO
 	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*data));
 	if (!indio_dev) {
 		dev_err(&pdev->dev, "failed to allocate iio device\n");
 		return -ENOMEM;
 	}
 	data = iio_priv(indio_dev);
-	data->pdev = pdev;
 	data->indio_dev = indio_dev;
+#else
+	data = devm_kmalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		dev_err(&pdev->dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+#endif
+	data->pdev = pdev;
 	data->status = CS1237_STATUS_IDLE;
 	data->dlock = 26;
 
@@ -538,6 +556,7 @@ static int cs1237_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+#ifdef CONFIG_IIO
 	/* register iio device */
 	data->channels[0].type = IIO_VOLTAGE;
 	data->channels[0].indexed = 1;
@@ -559,12 +578,17 @@ static int cs1237_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "failed to register iio device\n");
 		return ret;
 	}
+#endif
 
 	/* register misc device */
 	ret = misc_register(&cs1237_device);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register misc device\n");
+#ifdef CONFIG_IIO
 		goto unregister_iio;
+#else
+		goto free_data;
+#endif
 	}
 	dev_set_drvdata(cs1237_device.this_device, pdev);
 
@@ -597,8 +621,13 @@ static int cs1237_probe(struct platform_device *pdev)
 	goto done;
 unregister_misc:
 	misc_deregister(&cs1237_device);
+#ifdef CONFIG_IIO
 unregister_iio:
 	iio_device_unregister(indio_dev);
+#else
+free_data:
+	devm_kfree(&pdev->dev, data);
+#endif
 done:
 	if (ret)
 		dev_err(&pdev->dev, "failed to probe %d\n", ret);

commit d28216a2270c11783c0faa4fdc3c75f90b617794
Author: zhengzhuorui <zhengzhuorui@anycubic.com>
Date:   Fri Nov 3 09:59:54 2023 +0800

    cs1237: fix status sync
    
    Change-Id: If147c30378a23d035882197b8ef9e3abd84563d6
---
 drivers/misc/anycubic/cs1237.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/drivers/misc/anycubic/cs1237.c b/drivers/misc/anycubic/cs1237.c
index 791b7fa4..cb9b1edc 100644
--- a/drivers/misc/anycubic/cs1237.c
+++ b/drivers/misc/anycubic/cs1237.c
@@ -246,12 +246,16 @@ static inline bool cs1237_read_adc(int32_t *val)
 {
 	struct cs1237_data *data = cs1237_get_data();
 
+	spin_lock_irqsave(&data->slock, data->flags);
+
 	*val = data->adc_value;
 	/* 24bit extend to 32bit */
 	if (*val & (1 << 23))
 		*val |= -(((~(*val)) & 0x007FFFFF) + 1);
 
-	tasklet_schedule(&data->tasklet);
+	enable_irq(data->irq);
+	data->status = CS1237_STATUS_PREPARE;
+	spin_unlock_irqrestore(&data->slock, data->flags);
 	return true;
 }
 
@@ -278,11 +282,6 @@ static void cs1237_tasklet_handler(unsigned long arg)
 		cs1237_spi_read(3);
 		break;
 
-	case CS1237_STATUS_READY:
-		enable_irq(data->irq);
-		data->status = CS1237_STATUS_PREPARE;
-		break;
-
 	default:
 		break;
 	}

commit aa8fa43104e322fa67bf66f5b9e92dbcc315be09
Author: zhengzhuorui <zhengzhuorui@anycubic.com>
Date:   Tue Oct 31 15:27:33 2023 +0800

    Fix cs1237 header
    
    Change-Id: Icf1e99e88d1d9817d3820408ac8440f63fc2620c
---
 drivers/misc/anycubic/cs1237.h | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/misc/anycubic/cs1237.h b/drivers/misc/anycubic/cs1237.h
index ecd7dd5d..5b11ab9d 100644
--- a/drivers/misc/anycubic/cs1237.h
+++ b/drivers/misc/anycubic/cs1237.h
@@ -54,11 +54,11 @@ typedef enum {
 
 typedef union {
 	struct {
-		uint8_t		reserved	: 1;
-		uint8_t		refo_off	: 1;
-		uint8_t		speed		: 2;
-		uint8_t		pga		: 2;
 		uint8_t		channel		: 2;
+		uint8_t		pga		: 2;
+		uint8_t		speed		: 2;
+		uint8_t		refo_off	: 1;
+		uint8_t		reserved	: 1;
 	};
 	uint8_t			value;
 } cs1237_config_t;

commit 998d6efa6d31964965de5b6acd4fb440850d5cf3
Author: zhengzhuorui <zhengzhuorui@anycubic.com>
Date:   Mon Aug 28 17:58:03 2023 +0800

    cs1237: irq time stamp
    
    Change-Id: Ia20df1617bbbffad44e2495cbca04c133a33f62b
---
 drivers/misc/anycubic/cs1237.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/drivers/misc/anycubic/cs1237.c b/drivers/misc/anycubic/cs1237.c
index 139df537..791b7fa4 100644
--- a/drivers/misc/anycubic/cs1237.c
+++ b/drivers/misc/anycubic/cs1237.c
@@ -268,6 +268,9 @@ static void cs1237_tasklet_handler(unsigned long arg)
 		if (gpio_get_value(data->dio))
 			break;
 
+		if (time_after(jiffies, data->stamp + data->freq))
+			break;
+
 		disable_irq(data->irq);
 		data->status = CS1237_STATUS_READY;
 
@@ -292,6 +295,7 @@ static void cs1237_tasklet_handler(unsigned long arg)
 static irqreturn_t cs1237_irq_handler(int irq, void *dev_id)
 {
 	struct cs1237_data *data = (struct cs1237_data *)dev_id;
+	data->stamp = jiffies;
 	tasklet_schedule(&data->tasklet);
 	return IRQ_HANDLED;
 }

commit 0a204e15d6f7f8694071322e9e9e542d5f2ec1e7
Author: zhengzhuorui <zhengzhuorui@anycubic.com>
Date:   Mon Aug 28 13:46:45 2023 +0800

    Fix bug cs1237: read adc in tasklet
    
    Change-Id: I7c3b5308f3be01f79a488ee89a21fb8375307ca3
---
 drivers/misc/anycubic/cs1237.c | 25 ++++++++-----------------
 1 file changed, 8 insertions(+), 17 deletions(-)

diff --git a/drivers/misc/anycubic/cs1237.c b/drivers/misc/anycubic/cs1237.c
index cf23bf52..139df537 100644
--- a/drivers/misc/anycubic/cs1237.c
+++ b/drivers/misc/anycubic/cs1237.c
@@ -39,6 +39,7 @@ struct cs1237_data {
 	int			irq;
 	int			status;
 	unsigned long		flags;
+	int32_t			adc_value;
 
 	/* chip config */
 	cs1237_config_t config;
@@ -244,21 +245,8 @@ out:
 static inline bool cs1237_read_adc(int32_t *val)
 {
 	struct cs1237_data *data = cs1237_get_data();
-	uint8_t tires = 0;
-
-	spin_lock_irqsave(&data->slock, data->flags);
-	while (gpio_get_value_cansleep(data->dio)) {
-		if (tires++ > 10) {
-			spin_unlock_irqrestore(&data->slock, data->flags);
-			return false;
-		}
-		udelay(30);
-	}
-
-	*val = (int32_t)cs1237_spi_read(24);
-	cs1237_spi_read(3);
-	spin_unlock_irqrestore(&data->slock, data->flags);
 
+	*val = data->adc_value;
 	/* 24bit extend to 32bit */
 	if (*val & (1 << 23))
 		*val |= -(((~(*val)) & 0x007FFFFF) + 1);
@@ -273,18 +261,21 @@ static void cs1237_tasklet_handler(unsigned long arg)
 
 	spin_lock_irqsave(&data->slock, data->flags);
 	switch (data->status) {
+	case CS1237_STATUS_IDLE:
+		break;
+
 	case CS1237_STATUS_PREPARE:
 		if (gpio_get_value(data->dio))
 			break;
 
 		disable_irq(data->irq);
 		data->status = CS1237_STATUS_READY;
+
+		data->adc_value = (int32_t)cs1237_spi_read(24);
+		cs1237_spi_read(3);
 		break;
 
 	case CS1237_STATUS_READY:
-		if (!gpio_get_value(data->dio))
-			break;
-
 		enable_irq(data->irq);
 		data->status = CS1237_STATUS_PREPARE;
 		break;

commit 6705ab4928d3c44a523323705af08505506d2cab
Author: zhengzhuorui <zhengzhuorui@anycubic.com>
Date:   Wed Aug 2 10:24:35 2023 +0800

    cs1237: adc read timeout
    
    Change-Id: I02c0d35441e51318b4de865edfdb0d42f536f1e7
---
 drivers/misc/anycubic/cs1237.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/drivers/misc/anycubic/cs1237.c b/drivers/misc/anycubic/cs1237.c
index 673267e8..cf23bf52 100644
--- a/drivers/misc/anycubic/cs1237.c
+++ b/drivers/misc/anycubic/cs1237.c
@@ -244,10 +244,17 @@ out:
 static inline bool cs1237_read_adc(int32_t *val)
 {
 	struct cs1237_data *data = cs1237_get_data();
+	uint8_t tires = 0;
 
 	spin_lock_irqsave(&data->slock, data->flags);
-	while (gpio_get_value_cansleep(data->dio))
+	while (gpio_get_value_cansleep(data->dio)) {
+		if (tires++ > 10) {
+			spin_unlock_irqrestore(&data->slock, data->flags);
+			return false;
+		}
 		udelay(30);
+	}
+
 	*val = (int32_t)cs1237_spi_read(24);
 	cs1237_spi_read(3);
 	spin_unlock_irqrestore(&data->slock, data->flags);

commit a433c97ed5f56108def1ea01118ecc57e736d5e4
Author: zhengzhuorui <zhengzhuorui@anycubic.com>
Date:   Tue Aug 1 16:52:57 2023 +0800

    cs1237: Fix read
    
    Change-Id: I44d094944d3536dc3339d18a936591bf542f2bea
---
 drivers/misc/anycubic/cs1237.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/misc/anycubic/cs1237.c b/drivers/misc/anycubic/cs1237.c
index 9257b391..673267e8 100644
--- a/drivers/misc/anycubic/cs1237.c
+++ b/drivers/misc/anycubic/cs1237.c
@@ -246,6 +246,8 @@ static inline bool cs1237_read_adc(int32_t *val)
 	struct cs1237_data *data = cs1237_get_data();
 
 	spin_lock_irqsave(&data->slock, data->flags);
+	while (gpio_get_value_cansleep(data->dio))
+		udelay(30);
 	*val = (int32_t)cs1237_spi_read(24);
 	cs1237_spi_read(3);
 	spin_unlock_irqrestore(&data->slock, data->flags);

commit 255c7ada7cd0dce8bdf5f1f6efed72995eb24075
Author: zhengzhuorui <zhengzhuorui@anycubic.com>
Date:   Tue Aug 1 15:12:24 2023 +0800

    cs1237: irq save
    
    Change-Id: I77ae393c6c5ad4d9b1f5a53b1d41d604b990c5fc
---
 drivers/misc/anycubic/cs1237.c | 87 +++++++-----------------------------------
 1 file changed, 14 insertions(+), 73 deletions(-)

diff --git a/drivers/misc/anycubic/cs1237.c b/drivers/misc/anycubic/cs1237.c
index 234087e7..9257b391 100644
--- a/drivers/misc/anycubic/cs1237.c
+++ b/drivers/misc/anycubic/cs1237.c
@@ -10,7 +10,6 @@
 #include <linux/of_device.h>
 #include <linux/delay.h>
 #include <linux/jiffies.h>
-#include <linux/mutex.h>
 #include <linux/spinlock.h>
 #include <linux/uaccess.h>
 #include <linux/iio/iio.h>
@@ -19,7 +18,6 @@
 #include <linux/interrupt.h>
 #include <linux/poll.h>
 #include <linux/wait.h>
-#include <linux/workqueue.h>
 
 #include "cs1237.h"
 
@@ -35,13 +33,12 @@ struct cs1237_data {
 	struct platform_device	*pdev;
 	struct iio_dev		*indio_dev;
 	struct iio_chan_spec	channels[CS1237_NUM_CHANNELS];
-	struct delayed_work	work;
 	struct tasklet_struct	tasklet;
-	struct mutex		lock;
 	spinlock_t 		slock;
 	wait_queue_head_t	wait;
 	int			irq;
 	int			status;
+	unsigned long		flags;
 
 	/* chip config */
 	cs1237_config_t config;
@@ -204,10 +201,6 @@ static uint32_t cs1237_setup(uint8_t reg, uint8_t value)
 	struct cs1237_data *data = cs1237_get_data();
 	uint8_t tires = 0;
 
-	cancel_delayed_work_sync(&data->work);
-	if (data->status == CS1237_STATUS_PREPARE)
-		disable_irq(data->irq);
-	tasklet_disable(&data->tasklet);
 	while (gpio_get_value_cansleep(data->dio)) {
 		if (tires++ > 10) {
 			goto out;
@@ -217,7 +210,7 @@ static uint32_t cs1237_setup(uint8_t reg, uint8_t value)
 
 	data->freq = usecs_to_jiffies(cs1237_build_time(data->config.speed));
 
-	spin_lock(&data->slock);
+	spin_lock_irqsave(&data->slock, data->flags);
 	/* clock 0~27 discard */
 	cs1237_spi_read(27);
 
@@ -241,14 +234,10 @@ static uint32_t cs1237_setup(uint8_t reg, uint8_t value)
 	/* clock 46 */
 	gpio_direction_input(data->dio);
 	cs1237_spi_read(1);
-	spin_unlock(&data->slock);
+	spin_unlock_irqrestore(&data->slock, data->flags);
 
 	msleep(1);
 out:
-	tasklet_enable(&data->tasklet);
-	if (data->status == CS1237_STATUS_PREPARE)
-		enable_irq(data->irq);
-	schedule_delayed_work(&data->work, msecs_to_jiffies(100));
 	return value;
 }
 
@@ -256,13 +245,10 @@ static inline bool cs1237_read_adc(int32_t *val)
 {
 	struct cs1237_data *data = cs1237_get_data();
 
-	if (gpio_get_value_cansleep(data->dio))
-		return false;
-
-	spin_lock(&data->slock);
+	spin_lock_irqsave(&data->slock, data->flags);
 	*val = (int32_t)cs1237_spi_read(24);
 	cs1237_spi_read(3);
-	spin_unlock(&data->slock);
+	spin_unlock_irqrestore(&data->slock, data->flags);
 
 	/* 24bit extend to 32bit */
 	if (*val & (1 << 23))
@@ -272,47 +258,33 @@ static inline bool cs1237_read_adc(int32_t *val)
 	return true;
 }
 
-static void cs1237_work_heandler(struct work_struct *work)
-{
-	struct cs1237_data *data = container_of(work, struct cs1237_data, work.work);
-	tasklet_schedule(&data->tasklet);
-	schedule_delayed_work(&data->work, msecs_to_jiffies(100));
-}
-
 static void cs1237_tasklet_handler(unsigned long arg)
 {
 	struct cs1237_data *data = (struct cs1237_data *)arg;
 
-	mutex_lock(&data->lock);
+	spin_lock_irqsave(&data->slock, data->flags);
 	switch (data->status) {
 	case CS1237_STATUS_PREPARE:
-		// if (jiffies < data->stamp + data->dlock)
-		// 	break;
-
-		if (unlikely(gpio_get_value(data->dio)))
+		if (gpio_get_value(data->dio))
 			break;
 
 		disable_irq(data->irq);
 		data->status = CS1237_STATUS_READY;
-		data->stamp = jiffies;
 		break;
 
 	case CS1237_STATUS_READY:
-		// if (jiffies < (data->stamp + data->freq))
-		// 	break;
-
-		if (likely(!gpio_get_value(data->dio)))
+		if (!gpio_get_value(data->dio))
 			break;
 
 		enable_irq(data->irq);
 		data->status = CS1237_STATUS_PREPARE;
-		data->stamp = jiffies;
 		break;
 
 	default:
 		break;
 	}
-	mutex_unlock(&data->lock);
+	spin_unlock_irqrestore(&data->slock, data->flags);
+
 	wake_up_interruptible(&data->wait);
 }
 
@@ -324,13 +296,6 @@ static irqreturn_t cs1237_irq_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void cs1237_gpio_free(struct platform_device *pdev)
-{
-	struct cs1237_data *data = dev_get_drvdata(&pdev->dev);
-	gpio_free(data->dio);
-	gpio_free(data->dclk);
-}
-
 static int cs1237_gpio_request(struct platform_device *pdev)
 {
 	struct cs1237_data *data = dev_get_drvdata(&pdev->dev);
@@ -456,9 +421,6 @@ static ssize_t cs1237_read(struct file *file, char __user *buf,
 	if (!(file->f_flags & O_NONBLOCK))
 		wait_event_interruptible(data->wait, data->status == CS1237_STATUS_READY);
 
-	if (data->status != CS1237_STATUS_READY)
-		return -EAGAIN;
-
 	if (!cs1237_read_adc(&value))
 		return -EIO;
 
@@ -475,10 +437,8 @@ static unsigned int cs1237_poll(struct file *file, poll_table *wait)
 
 	poll_wait(file, &data->wait, wait);
 
-	mutex_lock(&data->lock);
 	if (data->status == CS1237_STATUS_READY)
 		mask |= POLLIN | POLLRDNORM;	/* readable */
-	mutex_unlock(&data->lock);
 
 	return mask;
 }
@@ -513,22 +473,13 @@ static int cs1237_remove(struct platform_device *pdev)
 	struct cs1237_data *data = platform_get_drvdata(pdev);
 	dev_info(&pdev->dev, "remove\n");
 
-	cancel_delayed_work_sync(&data->work);
-
 	tasklet_disable(&data->tasklet);
 	tasklet_kill(&data->tasklet);
-	if (data->status == CS1237_STATUS_PREPARE)
-		disable_irq(data->irq);
 	
 	misc_deregister(&cs1237_device);
 
 	iio_device_unregister(data->indio_dev);
 
-	cs1237_gpio_free(pdev);
-
-	mutex_destroy(&data->lock);
-
-	devm_iio_device_free(&pdev->dev, data->indio_dev);
 	return 0;
 }
 
@@ -562,13 +513,13 @@ static int cs1237_probe(struct platform_device *pdev)
 	ret = of_property_read_u32(np, "gpio-sck", &data->dclk);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "failed to get gpio-sck\n");
-		goto free_iio;
+		return ret;
 	}
 
 	ret = of_property_read_u32(np, "gpio-mosi", &data->dio);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "failed to get gpio-mosi\n");
-		goto free_iio;
+		return ret;
 	}
 	dev_info(&pdev->dev, "dclk: %d, dio: %d\n", data->dclk, data->dio);
 
@@ -603,7 +554,7 @@ static int cs1237_probe(struct platform_device *pdev)
 	ret = iio_device_register(indio_dev);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register iio device\n");
-		goto free_gpios;
+		return ret;
 	}
 
 	/* register misc device */
@@ -614,11 +565,9 @@ static int cs1237_probe(struct platform_device *pdev)
 	}
 	dev_set_drvdata(cs1237_device.this_device, pdev);
 
-	mutex_init(&data->lock);
 	spin_lock_init(&data->slock);
 	init_waitqueue_head(&data->wait);
 	tasklet_init(&data->tasklet, cs1237_tasklet_handler, (unsigned long)data);
-	INIT_DELAYED_WORK(&data->work, cs1237_work_heandler);
 
 	data->status = CS1237_STATUS_PREPARE;
 	ret = devm_request_irq(&pdev->dev, data->irq, cs1237_irq_handler,
@@ -627,13 +576,12 @@ static int cs1237_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "failed to request irq %d\n", data->irq);
 		goto unregister_misc;
 	}
-	schedule_delayed_work(&data->work, msecs_to_jiffies(100));
 
 	data->config.value = cs1237_setup(CS1237_REG_WR, 0x2C);
 	if (data->config.reserved) {
 		dev_err(&pdev->dev, "can not setup cs1237\n");
 		ret = -EIO;
-		goto err;
+		goto unregister_misc;
 	}
 
 	data->config.value = cs1237_setup(CS1237_REG_RD, 0);
@@ -644,17 +592,10 @@ static int cs1237_probe(struct platform_device *pdev)
 		 data->config.pga,
 		 data->config.channel);
 	goto done;
-err:
-	devm_free_irq(&pdev->dev, data->irq, pdev);
-	mutex_destroy(&data->lock);
 unregister_misc:
 	misc_deregister(&cs1237_device);
 unregister_iio:
 	iio_device_unregister(indio_dev);
-free_gpios:
-	cs1237_gpio_free(pdev);
-free_iio:
-	devm_iio_device_free(&pdev->dev, indio_dev);
 done:
 	if (ret)
 		dev_err(&pdev->dev, "failed to probe %d\n", ret);

commit 630d30ed0accc6383592336f223cdf8de7f393c1
Author: zhengzhuorui <zhengzhuorui@anycubic.com>
Date:   Wed Jul 26 11:47:16 2023 +0800

    Add misc driver: anycubic
---
 drivers/misc/anycubic/cs1237.c | 689 +++++++++++++++++++++++++++++++++++++++++
 drivers/misc/anycubic/cs1237.h |  71 +++++
 2 files changed, 760 insertions(+)

diff --git a/drivers/misc/anycubic/cs1237.c b/drivers/misc/anycubic/cs1237.c
new file mode 100644
index 00000000..234087e7
--- /dev/null
+++ b/drivers/misc/anycubic/cs1237.c
@@ -0,0 +1,689 @@
+#include <linux/miscdevice.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/uaccess.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/consumer.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/poll.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+
+#include "cs1237.h"
+
+#define CS1237_NUM_CHANNELS	1
+
+enum {
+	CS1237_STATUS_IDLE,
+	CS1237_STATUS_PREPARE,
+	CS1237_STATUS_READY,
+}; 
+
+struct cs1237_data {
+	struct platform_device	*pdev;
+	struct iio_dev		*indio_dev;
+	struct iio_chan_spec	channels[CS1237_NUM_CHANNELS];
+	struct delayed_work	work;
+	struct tasklet_struct	tasklet;
+	struct mutex		lock;
+	spinlock_t 		slock;
+	wait_queue_head_t	wait;
+	int			irq;
+	int			status;
+
+	/* chip config */
+	cs1237_config_t config;
+	unsigned 	dclk;	/* gpio: sclk */
+	unsigned 	dio;	/* gpio: DRDY/DOUT */
+	int 		ref;	/* ref voltage mV */
+	unsigned long	stamp;	/* read time stamp */
+	unsigned long	freq;	/* data ready time */
+	unsigned long	dlock;	/* data update time */
+};
+
+static int cs1237_open(struct inode *inode, struct file *file);
+static int cs1237_close(struct inode *inodep, struct file *filp);
+static ssize_t cs1237_read(struct file *file, char __user *buf,
+			   size_t len, loff_t *ppos);
+static ssize_t cs1237_write(struct file *file, const char __user *buf,
+			    size_t len, loff_t *ppos);
+static unsigned int cs1237_poll(struct file *file, poll_table *wait);
+static long cs1237_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+
+static const struct file_operations cs1237_fops = {
+	.owner = THIS_MODULE,
+	.read = cs1237_read,
+	.write = cs1237_write,
+	.open = cs1237_open,
+	.release = cs1237_close,
+	.poll = cs1237_poll,
+	.llseek = no_llseek,
+	.unlocked_ioctl = cs1237_ioctl,
+};
+
+struct miscdevice cs1237_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "cs1237",
+	.fops = &cs1237_fops,
+};
+
+#define cs1237_get_pdev() dev_get_drvdata(cs1237_device.this_device)
+#define cs1237_get_data() platform_get_drvdata(dev_get_drvdata(cs1237_device.this_device))
+
+#if 0
+static void cs1237_hw_reset(void)
+{
+}
+
+static void cs1237_set_pwrsave(int pwrsave)
+{
+	if (pwrsave && !cs1237_data->pwrsave) {
+		gpio_set_value_cansleep(cs1237_data->dclk, 1);
+		udelay(150);
+	} else {
+		gpio_set_value_cansleep(cs1237_data->dclk, 0);
+		udelay(20);
+	}
+}
+#endif
+
+static inline int cs1237_get_gain(int pga)
+{
+	switch (pga) {
+	case PGA_SEL_1:
+		return 1;
+	case PGA_SEL_2:
+		return 2;
+	case PGA_SEL_64:
+		return 64;
+	case PGA_SEL_128:
+		return 128;
+	}
+	return 0;
+}
+
+static inline unsigned int cs1237_build_time(int speed)
+{
+	/* hz to usec */
+	switch (speed) {
+	case SPEED_SEL_10HZ:
+		return 100000;
+	case SPEED_SEL_40HZ:
+		return 25000;
+	case SPEED_SEL_640HZ:
+		return 1563;
+	case SPEED_SEL_1280HZ:
+		return 781;
+	}
+	return 0;
+}
+
+#if 0
+/**
+ * adc format: singned 24bit
+ * positive max 7FFFFFH
+ * negative max 800000H
+ */
+static inline bool cs1237_data_validate(uint32_t value)
+{
+	if (value < 0X007FFFFF && value > 0XFF800000)
+		return false;
+	else
+		return true;
+}
+#endif
+
+/**
+ * @brief convert adc value to voltage
+ * 	voltage: (±0.5Vref/gain)/(2^23-1) * value
+ */
+static inline int64_t cs1237_get_votage(int64_t value)
+{
+	struct cs1237_data *data = cs1237_get_data();
+	int64_t ref  = data->ref;
+	int64_t gain = cs1237_get_gain(data->config.pga);
+	return ((ref * value * 1000000) / (gain * 0xFFFFFF));
+}
+
+static inline uint32_t cs1237_spi_read(uint8_t bits)
+{
+	struct cs1237_data *data = cs1237_get_data();
+	uint32_t value = 0;
+	uint8_t i;
+
+	for (i = 0; i < bits; i++) {
+		gpio_set_value(data->dclk, 1);
+		ndelay(500);
+
+		value <<= 1;
+		if (gpio_get_value(data->dio))
+			value |= 1;
+
+		gpio_set_value(data->dclk, 0);
+		ndelay(500);
+	}
+
+	return value;
+}
+
+static inline void cs1237_spi_write(uint32_t value, uint8_t bits)
+{
+	struct cs1237_data *data = cs1237_get_data();
+	uint8_t i;
+
+	for (i = 0; i < bits; i++) {
+		gpio_set_value(data->dclk, 1);
+		ndelay(500);
+
+		/* MSB first */
+		if (value & 0x80)
+			gpio_set_value(data->dio, 1);
+		else
+			gpio_set_value(data->dio, 0);
+		value <<= 1;
+
+		gpio_set_value(data->dclk, 0);
+		ndelay(500);
+	}
+}
+
+static uint32_t cs1237_setup(uint8_t reg, uint8_t value)
+{
+	struct cs1237_data *data = cs1237_get_data();
+	uint8_t tires = 0;
+
+	cancel_delayed_work_sync(&data->work);
+	if (data->status == CS1237_STATUS_PREPARE)
+		disable_irq(data->irq);
+	tasklet_disable(&data->tasklet);
+	while (gpio_get_value_cansleep(data->dio)) {
+		if (tires++ > 10) {
+			goto out;
+		}
+		udelay(30);
+	}
+
+	data->freq = usecs_to_jiffies(cs1237_build_time(data->config.speed));
+
+	spin_lock(&data->slock);
+	/* clock 0~27 discard */
+	cs1237_spi_read(27);
+
+	/* clock 28~29 */
+	gpio_direction_output(data->dio, 1);
+	cs1237_spi_read(2);
+
+	/* clock 30~36 write r/w cmd */
+	cs1237_spi_write(reg << 1, 7);
+
+	/* clock 37 */
+	cs1237_spi_read(1);
+
+	/* clock 38~45 r/w reg */
+	if (reg == CS1237_REG_RD) {
+		gpio_direction_input(data->dio);
+		value = cs1237_spi_read(8);
+	} else
+		cs1237_spi_write(value, 8);
+
+	/* clock 46 */
+	gpio_direction_input(data->dio);
+	cs1237_spi_read(1);
+	spin_unlock(&data->slock);
+
+	msleep(1);
+out:
+	tasklet_enable(&data->tasklet);
+	if (data->status == CS1237_STATUS_PREPARE)
+		enable_irq(data->irq);
+	schedule_delayed_work(&data->work, msecs_to_jiffies(100));
+	return value;
+}
+
+static inline bool cs1237_read_adc(int32_t *val)
+{
+	struct cs1237_data *data = cs1237_get_data();
+
+	if (gpio_get_value_cansleep(data->dio))
+		return false;
+
+	spin_lock(&data->slock);
+	*val = (int32_t)cs1237_spi_read(24);
+	cs1237_spi_read(3);
+	spin_unlock(&data->slock);
+
+	/* 24bit extend to 32bit */
+	if (*val & (1 << 23))
+		*val |= -(((~(*val)) & 0x007FFFFF) + 1);
+
+	tasklet_schedule(&data->tasklet);
+	return true;
+}
+
+static void cs1237_work_heandler(struct work_struct *work)
+{
+	struct cs1237_data *data = container_of(work, struct cs1237_data, work.work);
+	tasklet_schedule(&data->tasklet);
+	schedule_delayed_work(&data->work, msecs_to_jiffies(100));
+}
+
+static void cs1237_tasklet_handler(unsigned long arg)
+{
+	struct cs1237_data *data = (struct cs1237_data *)arg;
+
+	mutex_lock(&data->lock);
+	switch (data->status) {
+	case CS1237_STATUS_PREPARE:
+		// if (jiffies < data->stamp + data->dlock)
+		// 	break;
+
+		if (unlikely(gpio_get_value(data->dio)))
+			break;
+
+		disable_irq(data->irq);
+		data->status = CS1237_STATUS_READY;
+		data->stamp = jiffies;
+		break;
+
+	case CS1237_STATUS_READY:
+		// if (jiffies < (data->stamp + data->freq))
+		// 	break;
+
+		if (likely(!gpio_get_value(data->dio)))
+			break;
+
+		enable_irq(data->irq);
+		data->status = CS1237_STATUS_PREPARE;
+		data->stamp = jiffies;
+		break;
+
+	default:
+		break;
+	}
+	mutex_unlock(&data->lock);
+	wake_up_interruptible(&data->wait);
+}
+
+/* cs1237_irq_handler */
+static irqreturn_t cs1237_irq_handler(int irq, void *dev_id)
+{
+	struct cs1237_data *data = (struct cs1237_data *)dev_id;
+	tasklet_schedule(&data->tasklet);
+	return IRQ_HANDLED;
+}
+
+static void cs1237_gpio_free(struct platform_device *pdev)
+{
+	struct cs1237_data *data = dev_get_drvdata(&pdev->dev);
+	gpio_free(data->dio);
+	gpio_free(data->dclk);
+}
+
+static int cs1237_gpio_request(struct platform_device *pdev)
+{
+	struct cs1237_data *data = dev_get_drvdata(&pdev->dev);
+	int ret;
+
+	ret = devm_gpio_request_one(&pdev->dev, data->dclk, GPIOF_OUT_INIT_LOW,
+				    "cs1237-dclk");
+	if (ret) {
+		dev_err(&pdev->dev, "failed to request gpio dclk\n");
+		return ret;
+	}
+
+	ret = devm_gpio_request_one(&pdev->dev, data->dio, GPIOF_IN, "cs1237-dio");
+	if (ret) {
+		dev_err(&pdev->dev, "failed to request gpio dio\n");
+		goto free_dclk;
+	}
+
+	data->irq = gpio_to_irq(data->dio);
+	if (data->irq < 0) {
+		dev_err(&pdev->dev, "failed to get gpio irq\n");
+		goto free_dio;
+	}
+
+	goto done;
+free_dio:
+	devm_gpio_free(&pdev->dev, data->dio);
+free_dclk:
+	devm_gpio_free(&pdev->dev, data->dclk);
+done:
+	return ret;
+}
+
+static int cs1237_open(struct inode *inode, struct file *file)
+{
+	file->private_data = cs1237_get_data();
+	return 0;
+}
+
+static int cs1237_close(struct inode *inodep, struct file *filp)
+{
+	return 0;
+}
+
+static long cs1237_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct cs1237_data *data = file->private_data;
+	cs1237_config_t config;
+	int32_t value;
+	int ret = 0;
+
+	switch (cmd) {
+	case CS1237_IOC_SET_CONFIG:
+		if (copy_from_user(&config, (void __user *)arg, sizeof(config)))
+			return -EFAULT;
+		config.value = cs1237_setup(CS1237_REG_WR, config.value);
+		if (config.reserved)
+			return -EIO;
+		if (config.value != cs1237_setup(CS1237_REG_RD, 0))
+			return -EIO;
+		data->config = config;
+		break;
+	case CS1237_IOC_GET_CONFIG:
+		if (copy_to_user((void __user *)arg, &data->config, sizeof(data->config)))
+			return -EFAULT;
+		break;
+	case CS1237_IOC_GET_ADC:
+		if (!cs1237_read_adc(&value))
+			return -EAGAIN;
+		if (copy_to_user((void __user *)arg, &value, sizeof(value)))
+			return -EFAULT;
+		break;
+	default:
+		dev_info(&data->pdev->dev, "invalid ioctl cmd %#X\n", cmd);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static ssize_t cs1237_write(struct file *file, const char __user *buf,
+			    size_t len, loff_t *ppos)
+{
+	struct cs1237_data *data = file->private_data;
+	int32_t value;
+
+	if (len < sizeof(value))
+		return -EINVAL;
+
+	if (copy_from_user(&value, buf, sizeof(value)))
+		return -EFAULT;
+
+	if (value < 0 || value > 0xFF)
+		return -EINVAL;
+
+	if (data->status != CS1237_STATUS_READY)
+		return -EAGAIN;
+
+	data->config.value = cs1237_setup(CS1237_REG_WR, value);
+	if (data->config.reserved)
+		return -EIO;
+
+	data->config.value = cs1237_setup(CS1237_REG_RD, 0);
+	dev_info(&data->pdev->dev, "cfg %#X refo %d speed %d pga %d ch %d\n", \
+		 data->config.value,
+		 data->config.refo_off,
+		 data->config.speed,
+		 data->config.pga,
+		 data->config.channel);
+
+	return sizeof(value);
+}
+
+static ssize_t cs1237_read(struct file *file, char __user *buf,
+			   size_t len, loff_t *ppos)
+{
+	struct cs1237_data *data = file->private_data;
+	int32_t value;
+
+	if (len < sizeof(value))
+		return -EINVAL;
+
+	if (!(file->f_flags & O_NONBLOCK))
+		wait_event_interruptible(data->wait, data->status == CS1237_STATUS_READY);
+
+	if (data->status != CS1237_STATUS_READY)
+		return -EAGAIN;
+
+	if (!cs1237_read_adc(&value))
+		return -EIO;
+
+	if (copy_to_user(buf, &value, sizeof(value)))
+		return -EFAULT;
+
+	return sizeof(value);
+}
+
+static unsigned int cs1237_poll(struct file *file, poll_table *wait)
+{
+	struct cs1237_data *data = file->private_data;
+	unsigned int mask = 0;
+
+	poll_wait(file, &data->wait, wait);
+
+	mutex_lock(&data->lock);
+	if (data->status == CS1237_STATUS_READY)
+		mask |= POLLIN | POLLRDNORM;	/* readable */
+	mutex_unlock(&data->lock);
+
+	return mask;
+}
+
+static int cs1237_read_raw(struct iio_dev *indio_dev,
+			   const struct iio_chan_spec *chan,
+			   int *val, int *val2, long mask)
+{
+	struct cs1237_data *data = iio_priv(indio_dev);	
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		if (!cs1237_read_adc(val))
+			return -EAGAIN;
+		break;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = data->config.speed;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return IIO_VAL_INT;
+}
+
+static const struct iio_info cs1237_info = {
+	.read_raw = cs1237_read_raw,
+};
+
+static int cs1237_remove(struct platform_device *pdev)
+{
+	struct cs1237_data *data = platform_get_drvdata(pdev);
+	dev_info(&pdev->dev, "remove\n");
+
+	cancel_delayed_work_sync(&data->work);
+
+	tasklet_disable(&data->tasklet);
+	tasklet_kill(&data->tasklet);
+	if (data->status == CS1237_STATUS_PREPARE)
+		disable_irq(data->irq);
+	
+	misc_deregister(&cs1237_device);
+
+	iio_device_unregister(data->indio_dev);
+
+	cs1237_gpio_free(pdev);
+
+	mutex_destroy(&data->lock);
+
+	devm_iio_device_free(&pdev->dev, data->indio_dev);
+	return 0;
+}
+
+static int cs1237_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device_node *np;
+	struct cs1237_data *data;
+	struct iio_dev *indio_dev;
+
+	np = of_find_compatible_node(pdev->dev.of_node, NULL, "cs1237");
+	if (!np) {
+		dev_err(&pdev->dev, "no device tree node\n");
+		return -ENODEV;
+	}
+	dev_info(&pdev->dev, "compatible: %s\n", np->name);
+
+	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*data));
+	if (!indio_dev) {
+		dev_err(&pdev->dev, "failed to allocate iio device\n");
+		return -ENOMEM;
+	}
+	data = iio_priv(indio_dev);
+	data->pdev = pdev;
+	data->indio_dev = indio_dev;
+	data->status = CS1237_STATUS_IDLE;
+	data->dlock = 26;
+
+	platform_set_drvdata(pdev, data);
+
+	ret = of_property_read_u32(np, "gpio-sck", &data->dclk);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to get gpio-sck\n");
+		goto free_iio;
+	}
+
+	ret = of_property_read_u32(np, "gpio-mosi", &data->dio);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to get gpio-mosi\n");
+		goto free_iio;
+	}
+	dev_info(&pdev->dev, "dclk: %d, dio: %d\n", data->dclk, data->dio);
+
+	ret = of_property_read_u32(np, "ref-voltage", &data->ref);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to get ref-voltage, set default 3300 mV\n");
+		data->ref = 3300000;
+	}
+
+	ret = cs1237_gpio_request(pdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to request gpio\n");
+		return ret;
+	}
+
+	/* register iio device */
+	data->channels[0].type = IIO_VOLTAGE;
+	data->channels[0].indexed = 1;
+	data->channels[0].channel = 0;
+	data->channels[0].address = 0;
+	data->channels[0].info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
+	data->channels[0].info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);
+
+	indio_dev->dev.parent = &pdev->dev;
+	indio_dev->name = "cs1237";
+	indio_dev->info = &cs1237_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = data->channels;
+	indio_dev->num_channels = CS1237_NUM_CHANNELS;
+	indio_dev->available_scan_masks = (unsigned long *)BIT(0);
+
+	ret = iio_device_register(indio_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register iio device\n");
+		goto free_gpios;
+	}
+
+	/* register misc device */
+	ret = misc_register(&cs1237_device);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register misc device\n");
+		goto unregister_iio;
+	}
+	dev_set_drvdata(cs1237_device.this_device, pdev);
+
+	mutex_init(&data->lock);
+	spin_lock_init(&data->slock);
+	init_waitqueue_head(&data->wait);
+	tasklet_init(&data->tasklet, cs1237_tasklet_handler, (unsigned long)data);
+	INIT_DELAYED_WORK(&data->work, cs1237_work_heandler);
+
+	data->status = CS1237_STATUS_PREPARE;
+	ret = devm_request_irq(&pdev->dev, data->irq, cs1237_irq_handler,
+			       IRQF_TRIGGER_FALLING, "cs1237", data);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to request irq %d\n", data->irq);
+		goto unregister_misc;
+	}
+	schedule_delayed_work(&data->work, msecs_to_jiffies(100));
+
+	data->config.value = cs1237_setup(CS1237_REG_WR, 0x2C);
+	if (data->config.reserved) {
+		dev_err(&pdev->dev, "can not setup cs1237\n");
+		ret = -EIO;
+		goto err;
+	}
+
+	data->config.value = cs1237_setup(CS1237_REG_RD, 0);
+	dev_info(&pdev->dev, "cfg %#X refo %d speed %d pga %d ch %d\n", \
+		 data->config.value,
+		 data->config.refo_off,
+		 data->config.speed,
+		 data->config.pga,
+		 data->config.channel);
+	goto done;
+err:
+	devm_free_irq(&pdev->dev, data->irq, pdev);
+	mutex_destroy(&data->lock);
+unregister_misc:
+	misc_deregister(&cs1237_device);
+unregister_iio:
+	iio_device_unregister(indio_dev);
+free_gpios:
+	cs1237_gpio_free(pdev);
+free_iio:
+	devm_iio_device_free(&pdev->dev, indio_dev);
+done:
+	if (ret)
+		dev_err(&pdev->dev, "failed to probe %d\n", ret);
+	return ret;
+}
+
+static const struct platform_device_id cs1237_id_table[] = {
+	{ "anycubic", 0 },
+	{},
+};
+
+static const struct of_device_id cs1237_of_match[] = {
+	{ .compatible = "cs1237", },
+	{},
+};
+
+static struct platform_driver cs1237_driver = {
+	.probe = cs1237_probe,
+	.remove = cs1237_remove,
+	.id_table = cs1237_id_table,
+	.driver = {
+		.name = "cs1237",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(cs1237_of_match),
+	},
+};
+
+module_platform_driver(cs1237_driver);
+
+MODULE_DESCRIPTION("CS1237 ADC Driver");
+MODULE_AUTHOR("Zhengzhuorui <zhengzhuorui@anycubic.com>");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/drivers/misc/anycubic/cs1237.h b/drivers/misc/anycubic/cs1237.h
new file mode 100644
index 00000000..ecd7dd5d
--- /dev/null
+++ b/drivers/misc/anycubic/cs1237.h
@@ -0,0 +1,71 @@
+#ifndef _ANYCUBIC_CS1237_H_
+#define _ANYCUBIC_CS1237_H_
+
+#include <linux/types.h>
+#include <linux/bitops.h>
+#include <linux/ioctl.h>
+
+#define CS1237_REG_WR			0x65
+#define CS1237_REG_RD			0x56
+
+#define CS1237_REG_REFO_OFF		BIT(6)
+#define CS1237_REG_SLEEP_SEL		BIT(5) | BIT(4)
+#define CS1237_REG_PGA_SEL		BIT(3) | BIT(2)
+#define CS1237_REG_CH_SEL		BIT(1) | BIT(0)
+
+typedef enum {
+	REF_OUTPUT_ON	= 0,
+	REF_OUTPUT_OFF	= 1,
+	REF_OUTPUT_MAX
+} ref_output_e;
+
+typedef enum {
+	SPEED_SEL_10HZ = 0,
+	SPEED_SEL_40HZ,
+	SPEED_SEL_640HZ,
+	SPEED_SEL_1280HZ,
+	SPEED_SEL_MAX
+} speed_sel_e;
+
+typedef enum {
+	PGA_SEL_1 = 0,
+	PGA_SEL_2,
+	PGA_SEL_64,
+	PGA_SEL_128,
+	PGA_SEL_MAX
+} pga_sel_e;
+
+typedef enum {
+	CH_SEL_A = 0,
+	CH_SEL_RESERVED,
+	CH_SEL_TEMP,
+	CH_SEL_SC,
+	CH_SEL_MAX
+} channel_sel_e;
+
+typedef enum {
+	STATUS_OK		= 0,
+	STATUS_ERR,
+	STATUS_LOW_POWER,
+	STATUS_RESET,
+	STATUS_READY,
+	STATUS_MAX
+} status_e;
+
+typedef union {
+	struct {
+		uint8_t		reserved	: 1;
+		uint8_t		refo_off	: 1;
+		uint8_t		speed		: 2;
+		uint8_t		pga		: 2;
+		uint8_t		channel		: 2;
+	};
+	uint8_t			value;
+} cs1237_config_t;
+
+#define CS1237_IOC_MAGIC		'k'
+#define CS1237_IOC_SET_CONFIG		_IOW(CS1237_IOC_MAGIC, 1, cs1237_config_t)
+#define CS1237_IOC_GET_CONFIG		_IOR(CS1237_IOC_MAGIC, 2, cs1237_config_t)
+#define CS1237_IOC_GET_ADC		_IOR(CS1237_IOC_MAGIC, 3, int32_t)
+
+#endif /* _ANYCUBIC_CS1237_H_ */
\ No newline at end of file
